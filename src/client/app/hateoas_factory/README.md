# HATEOASFactory

HATEOASFactory outputs angular services based on a 'service definition' and combines it with their initial endpoint call to allow easy hal focused development within module controllers.

### Installation
Defined as a core MPS module and included via require. Example of  injection into a factory along with a service definition: 

```js
    define(['angular', 'contact', 'utility.formatters'], 
    function(angular, contact) {
        'use strict';
        angular.module('mps.serviceRequestContacts')
        .factory('NewFactory', ['$translate', 'HATEOASFactory', 
            function(serviceUrl, $translate, HATEAOSFactory, formatter) {
                var serviceDefinition = {
                    serviceName: 'contacts'
                };
                
                return new HATEOASFactory(serviceDefinition);
            }
        ]);
    });
```

## Overview
When the app starts it makes an initial end point call to /mps/ for a 'list' of the services we provide access to. It looks something like the structure below:

```js
{
  "_links" : {
    "contacts" : {
      "href" : "https://api.venus-dev.lexmark.com/mps/contacts{?page,size,sort}",
      "templated" : true
    }
  }
}
```

As you can see in the structure above we have one endpoint defined in _links{} and it is called 'contacts'. This is the service name. This initial call is used to power all generated functions within HATEOASFactory. The above call is made by the HATEOASConfig module with behaves as the store for our service endpoints; however, the given endpoint is attached to all generated services. Once attached a service will have service.url'', and service.params{} properties.

Now that we know the end point is there we can create a service definition and actually get going.

## Service Definitions
Service Definitions are angular factories that house an object that combines with the injected HATEOASFactory to output a service. Below is a definition for the contact endpoint outlined above. Note how the serviceName matches the endpont key we were given. This is a required property.

```js
define(['angular', 'contact'], function(angular) {
    'use strict';
    angular.module('mps.serviceRequestContacts')
    .factory('Contacts', ['$translate', 'HATEAOSFactory',
        var Contacts = {
            serviceName: 'contacts',
            columns: [
                {name: $translate.instant('CONTACT.EMAIL'), field: 'email'}
            ],
            route: '/service_requests/contacts'
        };

        return new HATEAOSFactory(Contacts);
        }
    ]);
});
```
Note any assigned defaults provided by HATEOASFactory will overwritten by provided service definitions properties as long as they have the same name. Further: functions, events, and objects can be outlined when needed.

## Using your new service within a controller
Now we have a service that will be generated by our factory. With this we can inject it elsewhere and begin to access our given endpoint.

### Getting paged content
Generally speaking our intital endpoint will return a collection of items. These items always end up in service.data[]. To make the initial call you do the following (again we used the assumed contacts service outlined above). With each page request the page{} property of the service is updated to match the response; along with params{}.


```js
    Contacts.get().then(function() {
        Contacts.data; // Has our collection
    });

```

To navigate within the context of the current page you can use next() and prev() which are based on the initial collections _links.self. They will return null if you cannot move in that direction.

```js
    Contacts.next().then(function(success) {
        Contacts.data; 
    });

    Contacts.prev().then(function(success) {
        Contacts.data; 
    });

```

To obtain a specific page use the following:

```js
    Contacts.params.page = 2;
    Contacts.params.size = 100;

    Contacts.get().then(function() {
        Contacts.data; // Page 2 size 100

        // You could reset to default param values with:
        Contacts.resetParams();
    });

```

### Getting single items
Generally speaking the services item{} property is set sometime after an initial paging call (as we do not know the end point to call). That said there is a provided pattern to call for a particular item only by ID. It is detailed at the bottom of this section; first we will outline the general cases.

Lets assume we have a set of items already in service.data[]. If we want to use the _links{} items of that particular item we need to set it in our services item{} property. If you were on a grid powered page reflecting a page collection you could do something like the following to obtain the item:

```js
    // in controller, function called in template
    $scope.goToContact = function(contact) {
        // Items are set this way so their _links can be attached as promises
        Contacts.setItem(contact);
    }

```

Now that we have something in Contacts.item a set of new functions related to the _links outline become available. For example; lets assume the items hal envelope had an 'account' link outling the items associated account; to get this you can do something like:

```js
    Contacts.item.account().then(function(processedResponse) {
        // then() gets back the full server response
        // We could set the item on another service with:
        Account.setItem(processedResponse);
    });

    // If we wanted to give params to Contacts.item.account()
    Contacts.item.account({key: 'value'}).then(function(processedResponse) {

    });

```

As mentioned above you can also directly call for an item; to do so use get():

```js
Contacts.get('123-XYT').then(function(processedResponse) {
    // this makes a call to contacts/123-XYT based on no HAL data
    // use at your own risk; since you are constructing the url from
    // something other than defined metadata.
});

```

NOTE: You could also make an http call manually and set the item via service.setItem();

## Saving

There are two methids related to getting information to our end points.

#### Contacts.put() / Contacts.item.put()
put() will make a PUT request to our root path, updates mainly

#### Contacts.post() / Contacts.item.post()
put() will make a POST request to our root path, typically used for initial saves.

An example: 

```js
    // Saving the structure in service.item
    Contacts.item.put().then(function() {

    });

    // Saving a a new item in service.item
    Contacts.post(item).then(function() {

    });

```


## Working with Parameters
All services has a params{} property that defines the parameters and values for the needed calls


## Working with collections (grids and etc)
The typical way to build out a grid with your service is to outline the following in a controller. The grid directive does need added to relevant templates and the grid module will need to be injected into the controller.

```js
    $scope.gridOptions = {};

    Contacts.get().then(function() {
        Grid.display(Contacts, $scope);
    }, function(reason) {
        NREUM.noticeError('Grid Load Failed for ' + Contacts.serviceName +  ' reason: ' + reason);
    });

```

## Events
There are a few events you can leverage within HATEOASFactory. They can be defined within the definition or attached to the service within the controller.


```js
    // fires before get executes, must return true or get() will fail
    beforeGet(halObj, deferred) 
    // fires when get begins
    onGet(halObj, deferred)
    // fires after get is successful 
    afterGet(halObj, deferred) 

    // fires before put exdcutes, must return true or put will fail
    beforePut(halObj, deferred) 
    onPut(halObj, deferred) 
    afterPut(halObj, deferred) 

    beforePost(halObj, deferred) 
    onPost(halObj, deferred) 
    afterPost(halObj, deferred) 

    onNextPage(halObj, deferred) 
    afterNextPage(halObj, deferred) 

    onFirstPage(halObj, deferred) 
    afterFirstPage(halObj, deferred) 

    onLastPage(halObj, deferred) 
    afterLastPage(halObj, deferred) 

    onDataSet(halObj, deferred) 
    onItemSet(halObj, deferred) 
```

## General Notes
    * Service.data[] holds multiple items -- think paged content.
    * Service.item holds a single item.
    * You can see the full response form the last call of any service provided by the factory by looking at the processedResponse property.
    * Service.setItem() puts an item into a services item{} slot and builds the needed functions from _links.
    * Service resetParams() resets the service to the params it had upon being initialized.































