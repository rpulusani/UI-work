# HATEOASFactory

HATEOASFactory outputs angular services based on a 'service definition' (think: fat model) and combines it with their initial endpoint call to allow easy hal focused development within module controllers.

**NOTE**: To prevent refactoring getPage(page, size), getAdditional(service, serviceDescription, params), save(), and update() are still supported functions.

* [Setup](#Setup)
* [Overview](#Overview)
* [Items](#Items)
* [Pages](#Pages)
* [Updates](#Updates)
* [Parameters](#Parameters)
* [Grid](#Grid)
* [Events](#Events)
* [Examples](#Examples)

## Setup

### Installation
Defined as a core MPS module and included via require. Example of injection into a factory along with a service definition: 

```js
    define(['angular', 'contact'], 
    function(angular, contact) {
        'use strict';
        angular.module('mps.serviceRequestContacts')
        .factory('NewFactory', ['HATEOASFactory', 
            function(HATEOASFactory) {
                var serviceDefinition = {
                    serviceName: 'contacts'
                };
                
                return new HATEOASFactory(serviceDefinition);
            }
        ]);
    });
```

### Context
When the app starts it makes an initial end point call to /mps/ for a 'list' of the services we provide access to. It looks something like the structure below:

```js
{
  "_links" : {
    "contacts" : {
      "href" : "https://api.venus-dev.lexmark.com/mps/contacts{?page,size,sort}",
      "templated" : true
    }
  }
}
```

As you can see in the structure above we have one endpoint defined in _links{} and it is called 'contacts'. This is the service name. This initial call is used to power all generated functions within HATEOASFactory. The above call is made by the HATEOASConfig module with behaves as the store for our service endpoints; however, the given endpoint is attached to all generated services. Once attached a service will have service.url'', and service.params{} properties.

Now that we know the end point is there we can create a service definition and actually get going.

### Service Definitions
Service Definitions are angular factories that house an object that combines with the injected HATEOASFactory to output a service. Below is a definition for the contact endpoint outlined above. Note how the serviceName matches the endpont key we were given. This is a required property.

```js
define(['angular', 'contact'], function(angular) {
    'use strict';
    angular.module('mps.serviceRequestContacts')
    .factory('Contacts', ['$translate', 'HATEOASFactory',
        var Contacts = {
            // service name must match to end point key
            serviceName: 'contacts',
            // given to grid for column sets
            columns: [
                {name: $translate.instant('CONTACT.EMAIL'), field: 'email'}
            ],
            // used to make client site routes consistent
            route: '/service_requests/contacts'
        };

        return new HATEOASFactory(Contacts);
    }]);
});

```
Note any assigned defaults provided by HATEOASFactory will overwritten by provided service definitions properties as long as they have the same name. Further: functions, events, and objects can be outlined when needed.

### Using your new service
Now we have a service being generated by HATEOASFactory we can inject it elsewhere, like you would any angular service, and begin to access our assigned endpoint.

## Overview
The service definition is used to extend HATEOASFactory which grants us a handful of handy powers.

### Functions

#### get(options)
Used to obtain info. Returns a promise. Options object can have a number of possible properties:

```js
    {
        // blocks native params (given in initial call)
        preventDefaultParams: true, 
        // adding params
        params: { 
            firstName: 'Gob',
            lastName: 'Blooth'
        },
        // a hal item
        item: {},
        // seek out a _link in options.item or self.item
        link: '',
        // override url for this call
        url: '',
        method: '' // change the request method
    }
```

#### post(options)

#### put(options)

#### setItem(item)
Puts the item into Service.item and attaches some functions.

#### createItem(item)
Output an item object with the HATEOASFactory functions attached.

#### all(options) 
Wait for all of an attached self.items._links to be called before executing. All is not attached to the root service ( Service.all() ), and any found self link is omitted by default. all() has a few options not found in the other functions:

```js
    {
        // link specific params
        account: {
            // any outside properties can be makde specific, ex:
            params: {key: 'value'},
            preventDefaultParams: false
        },
        // pass in link names you wish to omit,
        omit: [],
        // avoid calling _links.self
        omitSelf: true
    }
```

#### getPage(pageNumber, resultSize)
Convenience function for page navigation.

#### next()
Follows the given next _link, returns null if it cannot.

#### prev()
Follows the given prev _link, returns null if it cannot.

#### getAdditional(Service, NewService)
getAdditional() takes in two HATEOASFactory services and sets item two up with the data found in a link in service one. For example:

```js
    self.getAdditional(Devices.item, MeterReads).then(function() {
        // Meter reads link in Devices.item._links['meter-reads']
        // was called and give to MeterReads service. 
        // data in MeterReads.data
        MeterReads.get().then(function() {

        });
    });
    
```

#### Link functions
Created from an envelopes _links data via setItem/createItem. Links functions can process the same options as get(). Data is attached to Service.item.linkName.data or Service.item.linkName.item. Returns a promise passing in the full server response.

Examples:

```js
    Service.item.links.property(options);
    Service.item.links.['ugly-property'](options);

```

### Properties
These are some of the commonly used properties within a HATEOASFactory Service.

#### Service.serviceName
A unique name for the service; should reflect the endpoint

#### Service.embeddedName
Often embedded data is not under its 'service name'.

#### Service.url
Base url of the service.

#### Service.item
Where the 'working item' is stored. Should always match the services domain.

#### Service.data
Current collection/page is stored here.

#### Service.defaultParams
Placeholder for the original params given to us from server

#### Service.params
Working param values.

#### Service.page
HAL Page object given to Service form the latest call.

#### Service.processedResponse
The full response from the last HTTP request

#### Service.column
The name of the column definition to use.

#### Service.columnDefs
Different possible column sets; assigned by setting Service.column

## Items
The Service.item property is set sometime after an initial paging call (as we do not know the end point to call); it should be a hal envelope. 

Lets assume we have a set of items already in service.data[]. If we want to use the _links{} items of a particular item we need to put it into services.item with Service.setItem().

```js
    // in controller, function called in template ng-click
    $scope.goToContact = function(contact) {
        Contacts.setItem(contact);

        // This also works but you will not generate any links
        Contact.item = contact;
    }

```

Now that we have something in Contacts.item a set of new functions related to the _links outline become available. For example; lets assume the items hal envelope had a an accounts _link defined:

```js
    Contacts.item.links.accounts({
        embeddedName: 'account'
    }).then(function() {
        Grid.display(Contacts.item.account);
    });

    // or

    Contacts.get({
        link: 'accounts' // looking at Contacts.item._links.account
    }).then(function(serverResponse) {
        // We're just given the serverResponse when used this way
    });

    // For good measure

    Devices.item.links.meterReads().then(function() {
        // Devices.item.meterReads.data
    });

```

Service.item.all() lets you fire all links before execution, remember that it will wait for all calls to resolve before continuing; so in some cases you may prefer to call the links asynchronously. Self is omitted by default.

```js

    Contacts.item.all().then(function() {
        // data in Contacts.item.address.data
    });

    // You can also target specific links with options
    Contacts.all({
        // the omit array will let you skip a set of links
        omit: ['address'],
        account: {
            params: {
                firstName: 'Buster',
                lastName: 'Blooth'
            }
        }
    }).then(function() {
        // Contacts.all.
    });

```

## Pages
Generally speaking our initital endpoint will return a collection of items. These items always end up in service.data[]. With each page request the page{} property of the service is updated to match the response; along with params{}. You can also navigate the pages data of an item. The data is first obtained through a 'link function' and paged afterward. See examples below.

```js
    Contacts.get().then(function() {
        Contacts.data; // Has our collection
    });

```

To navigate within the context of the current page you can use next() and prev() which are based on the initial collections _links.self. They will return null if you cannot move in that direction.

```js
    Contacts.next().then(function(success) {
        Contacts.data; 
    });

    Contacts.prev().then(function(success) {
        Contacts.data; 
    });

```

To obtain a specific page set the required parameters:

```js
    Contacts.params.page = 2;
    Contacts.params.size = 100;

    Contacts.get().then(function() {
        Contacts.data; // Page 2 size 100

        // You could reset to default param values with:
        Contacts.params = Contacts.defaultParams;
    });

    // Can also use getPage()

    Contacts.getPage().then(function() {

    });

```

Want to navigate paged data returned by a link function? Do something like the following on an item attached with setItem():

```js
    Device.item.links.meterReads().then(function() {
        var meterReads = Device.item.meterReads.data;

        Grid.display(meterReads, $scope);
    });

```

## Updates

There are two methods related to getting information to our end points.

#### Service.put()
put() will make a PUT request to our root path, updates mainly

#### Service.post()
put() will make a POST request to our root path, typically used for initial saves.

An example: 

```js
    // Saving the structure in Contacts.item
    Contacts.put().then(function() {

    });

    // Saving a a new item, if no item is given service.item is sent if found
    Contacts.post({
        item: item
    }).then(function() {

    });

```

## Parameters
All services have a params{} property that defines the parameters and values for the needed calls. All parameters are sent with every call to Service.get() -- this is because the service defaults to using the entire set given to it by the intial endpoint call. Parameters set to null are never sent.

Example of a unmodified get() call:
```js
    // .../contacts?page=0&size=20 
    Contacts.get().then(function() {

    });
```

Example of adding a custom parameters to the call:

```js
    // .../contacts?page=20&size=20&firstName=Gob&lastName=Blooth
    Contacts.get({
        params: {
            firstName: 'Gob',
            lastName: 'Blooth'
        }
    });

    // if you didn't want to send page/size you can set them to null
    // or do something like the below
    // .../contacts?firstName=Gob&lastName=Blooth
    Contacts.get({
        preventDefaultParams: true, // blocks native params
        params: {
            firstName: 'Gob',
            lastName: 'Blooth'
        }
    });

    // .../contacts?page=20&size=20&lastName=Blooth
    Contacts.params.lastName = 'Blooth';

    Contacts.get().then(function() {
        // if you had the need you could reset:
        Contacts.params = Contacts.defaultParams;
    });;

    // Options object can be given page/size as well
    // .../contacts?page=1&size=100
    Contacts.get({
        page: 1, // 0 index for pages so this is the second page
        size: 100
    }).then(function() {

    });

```

## Grid
The typical way to build out a grid with your service is to outline the following in a controller. The grid directive does need added to relevant templates and the grid module will need to be injected into the controller.

```js
    $scope.gridOptions = {};

    Contacts.get().then(function() {
        Grid.display(Contacts, $scope);
    }, function(reason) {
        NREUM.noticeError('Grid Load Failed for ' + Contacts.serviceName +  ' reason: ' + reason);
    });

```

Its important to remember that the grid does not expect a service per se, but an object that has columns'', columnDefs{}, and data[] defined.

#### Columns
Unless we specifically outline a column set the grid will display everything; to clean that up (and to add i18n abilities) we define columns in our service definition:

```js
    // default, defaultSet, false attach the defaultSet columnDef
    columns: 'default',
    columnDefs: {
        defaultSet: [
            {name: $translate.instant('CONTACT.FULLNAME'), field: 'getFullname()'},
            {name: $translate.instant('CONTACT.ADDRESS'), field: 'getAddress()'}
        ],
        // Addtional sets can be defined
        testSet: [
            {name: $translate.instant('CONTACT.WORK_PHONE'), field: 'getWorkPhone()'},
            {name: $translate.instant('CONTACT.ALT_PHONE'), field: 'getAltPhone()'}
        ],
        // using a function to return a column set
        fullSet: function() {
            var arr = [];

            arr = arr.concat(this.defaultSet).concat(this.testSet);

            arr.push({
                name: $translate.instant('CONTACT.EMAIL'),
                field: 'email'
            });

            return arr;
        }
    }
```

#### Dynamic Columns
You can switch to a new set of columns anytime by reinitialzing the grid after pointing the service to a new set.

```js
    Contacts.columns = 'fullSet'; // fires fullset() returning all columns

```

## Events
There are a few events you can leverage within HATEOASFactory. They can be defined within the definition or attached to the service within the controller.

```js
    // before events fire before execution, must return true or function will fail
    // on events added to the stack when function begins
    // afrer events fired at end of execution
    // all outlined events must resolve the deferred

    beforeGet
    onGet
    afterGet

    beforePut
    onPut
    afterPut

    beforePost
    onPost
    afterPost

    onNext
    onPrev

```

There are example use cases for events in the 'Example Problems' section.

## Examples

#### If I were working with devices and wanted a particular devices meter read data -- how would I do it?

```js
    // This simply makes the call and returns the response
    Devices.get({item: deviceItem, link: 'meter-reads'}).then(function(serverResponse) {

    });

    // You can also

    Devices.setItem(Devices.item);
    Devices.item.links.['meter-reads']().then(function() {
        // Data is in
        Devices.item['meter-reads'].data;

        // Involved example, lets get the device again
        Devices.item['meter-reads'] = Devices.createItem(Devices.item[meter-reads]);

        Devices.item['meter-reads'].links.device().then(function() {

        });

        // Could also do
        var meterReads = createItem(Devices.item[meter-reads]);
        meterReads.links.device().then(function() {

        });
    });

```

#### What if I have a structure that relates to another service and that is embedded in my current data -- put another way: How would I work with an address attached to a contact?

```js

    Contact.get({
        link: 'address'
    }, function(address) {
        Addresses.item = address;
        // Now you can pass to Grid
    });

```

#### How do I call an items self link?

```js
    Contact.item.links.self().then(function() {
        // Contact.item.self
    });

```

#### How can I move two pages ahead?

```js
    Contacts.params.page = Contacts.params.page + 2;
    Contacts.get().then(function() {

    });

    // Or

    Contacts.get({
        page: Contacts.params.page + 2
    }).then(function() {

    });

    // With an item
    Contacts.item.params.page = Contacts.item.params.page + 2;
    Contacts.item.get().then(function() {

    });
```

#### How can I get the base url of the service?

```js
    Contacts.url; // String

```

#### How can I get the base url of an attached item?

```js
    Contacts.item._links.self.href;

```

#### I am creating an item across different views/templates -- how do I keep track of it?

Keep track of the item in Service.item as you work. When it is time to save call Service.post(). If you are performing tasks that are overwriting Service.item just store it in a secondary service property; ie: Service.newItem.

#### What problems do events solve? Do you have any examples?

Geez, you're demanding.

Lets say you're going to save an item but it doesnt meet the expected form. You could check it within the controller, or you can leverage the beforePost event to define something that will span across your service instances.

The following will make sure any item that we try to save has an associated account:
```js
    beforeSave: function(halObj, deferred) {
        halObj._links.account = {
            href: ''
        };

        // must return true, and pass in the new item if there were modifications
        deferred.resolve(true, halObj);
    }

```

In the following example we implement a counter tracking the total times we've called put() via the afterPut() event.
```js
    updateCnt: 0,
    afterPut: function(halObj, deferred) {
        this.updateCnt += 1;
        deferred.resolve();
    }

```

Lastly, this example outlines how to perform a save through an injected service with an onPost() event.
```js
    onPost: function(halObj, deferred) {
        Service.post(halObj.serviceItem).then(function(response) {
            deferred.resolve();
        });
    }

```

#### What if I want to override my default end point url?

You can define a new url by setting the url property in the service definition. All default values can be extended by defining them within the definition. You can route services to the node server on a per module basis.

#### Can I add a function to my service?

Yes. Just add it to the service definition and it will be accessible via Service.function().

#### Is there a way to know what links I have access to?
Yes, use one of the following:

```js
    var linkName;
    
    for (linkName in halObj._links) {

    }

    // or this item specific function

    Service.item.linkNames // ['account', 'self']
```
#### I am looking through a number of items; in a for loop, how can I keep track of the responses?
Use a closure.

```js
     Reports.getPage().then(function() {
        var i = 0,
        report;

       $scope.reports = Reports.data;

        for (i; i < $scope.reports.length; i += 1) {
            report = Reports.createItem($scope.reports[i]);
            report.stats.params.page = null;
            report.stats.params.size = null;

            (function(report) {
                report.links.stats().then(function() {
                    // data in report.stats.data
                });
            }(report));
        }
    });

```
