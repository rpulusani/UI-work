# HATEOASFactory

HATEOASFactory outputs angular services based on a 'service definition' (think: fat model) and combines it with their initial endpoint call to allow easy hal focused development within module controllers.

NOTE: To prevent refactoring getPage(page, size), save(), and update() are still supported functions that call get(), post(), and put() respectively.

### Installation
Defined as a core MPS module and included via require. Example of  injection into a factory along with a service definition: 

```js
    define(['angular', 'contact'], 
    function(angular, contact) {
        'use strict';
        angular.module('mps.serviceRequestContacts')
        .factory('NewFactory', ['HATEOASFactory', 
            function(HATEOASFactory) {
                var serviceDefinition = {
                    serviceName: 'contacts'
                };
                
                return new HATEOASFactory(serviceDefinition);
            }
        ]);
    });
```

## Overview
When the app starts it makes an initial end point call to /mps/ for a 'list' of the services we provide access to. It looks something like the structure below:

```js
{
  "_links" : {
    "contacts" : {
      "href" : "https://api.venus-dev.lexmark.com/mps/contacts{?page,size,sort}",
      "templated" : true
    }
  }
}
```

As you can see in the structure above we have one endpoint defined in _links{} and it is called 'contacts'. This is the service name. This initial call is used to power all generated functions within HATEOASFactory. The above call is made by the HATEOASConfig module with behaves as the store for our service endpoints; however, the given endpoint is attached to all generated services. Once attached a service will have service.url'', and service.params{} properties.

Now that we know the end point is there we can create a service definition and actually get going.

## Service Definitions
Service Definitions are angular factories that house an object that combines with the injected HATEOASFactory to output a service. Below is a definition for the contact endpoint outlined above. Note how the serviceName matches the endpont key we were given. This is a required property.

```js
define(['angular', 'contact'], function(angular) {
    'use strict';
    angular.module('mps.serviceRequestContacts')
    .factory('Contacts', ['$translate', 'HATEOASFactory',
        var Contacts = {
            // service name must match to end point key
            serviceName: 'contacts',
            // given to grid for column sets
            columns: [
                {name: $translate.instant('CONTACT.EMAIL'), field: 'email'}
            ],
            // used to make client site routes consistent
            route: '/service_requests/contacts'
        };

        return new HATEOASFactory(Contacts);
        }
    ]);
});
```
Note any assigned defaults provided by HATEOASFactory will overwritten by provided service definitions properties as long as they have the same name. Further: functions, events, and objects can be outlined when needed.

## Using your new service within a controller
Now we have a service that will be generated by our factory. With this we can inject it elsewhere and begin to access our given endpoint.

### Getting paged content
Generally speaking our initital endpoint will return a collection of items. These items always end up in service.data[]. To make the initial call you do the following (again we used the assumed contacts service outlined above). With each page request the page{} property of the service is updated to match the response; along with params{}.


```js
    Contacts.get().then(function() {
        Contacts.data; // Has our collection
    });

```

To navigate within the context of the current page you can use next() and prev() which are based on the initial collections _links.self. They will return null if you cannot move in that direction.

```js
    Contacts.next().then(function(success) {
        Contacts.data; 
    });

    Contacts.prev().then(function(success) {
        Contacts.data; 
    });

```

To obtain a specific page use the following:

```js
    Contacts.params.page = 2;
    Contacts.params.size = 100;

    Contacts.get().then(function() {
        Contacts.data; // Page 2 size 100

        // You could reset to default param values with:
        Contacts.params = Contacts.defaultParams;
    });

```

### Getting single items
The services item{} property is set sometime after an initial paging call (as we do not know the end point to call). That said there is a provided pattern to call for a particular item only by ID. It is detailed at the bottom of this section; first we will outline the general cases.

Lets assume we have a set of items already in service.data[]. If we want to use the _links{} items of that particular item we need to set it in our services item{} property. If you were on a grid powered page reflecting a page collection you could do something like the following to obtain the item:

```js
    // in controller, function called in template
    $scope.goToContact = function(contact) {        
        Contacts.item = contact;

        // Call this to attach _links routes as functions
        // You wouldn't need this if you were creating a new item.
        Contacts.setupItem();
    }

    // if you know you need access to the items _links you can skip
    // the assignment and do:
    Contacts.setupItem(contact);

```

Now that we have something in Contacts.item a set of new functions related to the _links outline become available. For example; lets assume the items hal envelope had an 'account' link outling the items associated account; to get this you can do something like:

```js
    Contacts.item.account().then(function(processedResponse) {
        // then() gets back the full server response
        // We could set the item on another service with:
        Account.setItem(processedResponse);
    });

    // If we wanted to give params to Contacts.item.account()
    Contacts.item.account({key: 'value'}).then(function(processedResponse) {

    });

```

Service.item.all() lets you fire all links before execution
```js
    Contacts.all().then(function(res) {
        // res = {linkName: response}
    });

    // You can also target specific links with options
    Contacts.all({
        // the omit array will let you skip a set of links
        omit: ['accounts'],
        linkName: {
            params: {
                firstName: 'Buster',
                lastName: 'Blooth'
            }
        }
    }).then(function() {

    });

```

As mentioned above you can also directly call for an item; to do so use get():

```js
    Contacts.get('123-XYT').then(function(processedResponse) {
        // this makes a call to contacts/123-XYT based on no HAL data
        // use at your own risk; since you are constructing the url from
        // something other than defined metadata.
        // You could also make an http call manually and set the item on your service.
    });

```

## Updating and Saving

There are two methods related to getting information to our end points.

#### Service.put()
put() will make a PUT request to our root path, updates mainly

#### Service.post()
put() will make a POST request to our root path, typically used for initial saves.

An example: 

```js
    // Saving the structure in Contacts.item
    Contacts.put().then(function() {

    });

    // Saving a a new item, if no item is given service.item is sent if found
    Contacts.post(item).then(function() {

    });

```

## Working with Query Parameters
All services have a params{} property that defines the parameters and values for the needed calls. All parameters are sent with every call to Service.get() -- this is because the service defaults to using the entire set given to it by the intial endpoint call. Parameters set to null are never sent.

Example of a unmodified get() call:
```js
    // note sort is not sent because it defaults to null
    // .../contacts?page=0&size=20 
    Contacts.get().then(function() {

    });
```

Example of adding a custom parameters to the call:

```js
    // this is referred to as the options object
    // .../contacts?page=20&size=20&firstName=Gob&lastName=Blooth
    Contacts.get({
        params: {
            firstName: 'Gob',
            lastName: 'Blooth'
        }
    });

    // if you didn't want to send page/size you can set them to null
    // or do something like the below
    // .../contacts?firstName=Gob&lastName=Blooth
    Contacts.get({
        preventDefaultParams: true, // blocks native params
        params: {
            firstName: 'Gob',
            lastName: 'Blooth'
        }
    });

    // .../contacts?page=20&size=20&lastName=Blooth
    Contacts.params.lastName = 'Blooth';

    Contacts.get().then(function() {
        // if you had the need you could reset:
        Contacts.params = Contacts.defaultParams;
    });;

    // Options object can be given page/size as well
    // .../contacts?page=1&size=100
    Contacts.get({
        page: 1, // 0 index for pages so this is the second page
        size: 100
    }).then(function() {

    });

```

Lastly, working with parameters with link functions:

```js
    // .../devices/meter-reads?key=value
    Devices.item.meterReads({
        key: 'value',
    }).then(function() {

    });
```

## Working with collections (grids and etc)
The typical way to build out a grid with your service is to outline the following in a controller. The grid directive does need added to relevant templates and the grid module will need to be injected into the controller.

```js
    $scope.gridOptions = {};

    Contacts.get().then(function() {
        Grid.display(Contacts, $scope);
    }, function(reason) {
        NREUM.noticeError('Grid Load Failed for ' + Contacts.serviceName +  ' reason: ' + reason);
    });

```

Its important to remember that the grid does not expect a service per se, but an object that has columns'', columnDefs{}, and data[] defined.

#### Columns
Unless we specifically outline a column set the grid will display everything; to clean that up (and to add i18n abilities) we define columns in our service definition:

```js
    // default, defaultSet, false attach the defaultSet columnDef
    columns: 'default',
    columnDefs: {
        defaultSet: [
            {name: $translate.instant('CONTACT.FULLNAME'), field: 'getFullname()'},
            {name: $translate.instant('CONTACT.ADDRESS'), field: 'getAddress()'}
        ],
        // Addtional sets can be defined
        testSet: [
            {name: $translate.instant('CONTACT.WORK_PHONE'), field: 'getWorkPhone()'},
            {name: $translate.instant('CONTACT.ALT_PHONE'), field: 'getAltPhone()'}
        ],
        // using a function to return a column set
        fullSet: function() {
            var arr = [];

            arr = arr.concat(this.defaultSet).concat(this.testSet);

            arr.push({
                name: $translate.instant('CONTACT.EMAIL'),
                field: 'email'
            });

            return arr;
        }
    }
```

#### Dynamic Columns
You can switch to a new set of columns anytime by reintialzing the grid after pointing the service to a new set.

```js
    Contacts.columns = 'fullSet'; // fires fullset() returning all columns

```

## Events
There are a few events you can leverage within HATEOASFactory. They can be defined within the definition or attached to the service within the controller.

```js
    // before events fire before execution, must return true or function will fail
    // on events added to the stack when function begins
    // afrer events fired at end of execution

    beforeGet(halObj, deferred) 
    onGet(halObj, deferred)
    afterGet(halObj, deferred) 

    beforePut(halObj, deferred) 
    onPut(halObj, deferred) 
    afterPut(halObj, deferred) 

    beforePost(halObj, deferred) 
    onPost(halObj, deferred) 
    afterPost(halObj, deferred) 

    onNext(halObj, deferred) 

    onPrev(halObj, deferred) 

    onItemSetup(halObj, deferred) 
```

There are example use cases for events in the 'Example Problems' section.

## Example Problems

#### If I were working with devices and wanted a particular devices meter read data -- how would I do it?

```js
    // Assuming Devices.item is defined
    Devices.item.meterReads().then(function(serverResponse) {

    });

    // Passing a parameter to meter reads
    Devices.item.meterReads({
        params: {key: 'value'}
    }).then(function(serverResponse) {

    });
```

#### What if I have a structure that relates to another service and was simply embedded in my current data -- put another way: How would I work with an address attached to a contact?

```js
    Addresses.setItem(Contacts.item.address);

    // Need a hal envelope for this items links? If so do:
    Addresses.item.self().then(function() {
        // Addresses.item should have been refreshed with a direct call
    });

```

#### How do I call an items self link?

```js
    Contacts.item.self().then(function() {

    });

```

#### How can I move two pages ahead?

```js
    Contacts.params.page = Contacts.params.page + 2;

    Contacts.get().then(function() {

    });

    // Or

    Contacts.get({
        page: Contacts.params.page + 2
    }).then(function() {

    });

```

#### How can I get the base url of the service?

```js
    Contacts.url; // String

```

#### How can I get the base url of an attached item?

```js
    Contacts.item._links.self.href;

```

#### I am creating an item across different views/templates -- how do I keep track of it?

Keep track of the item in Service.item as you work. When it is time to save call Service.post().


#### What problems do events solve? Do you have any examples?

Geez, you're demanding.

Lets say you're going to save an item but it doesnt meet the expected form. You could check it within the controller, or you can leverage the beforePost event to define something that will span across your service instances.

The following will make sure any item that we try to save has an associated account:
```js
    beforeSave: function(halObj, deferred) {
        halObj._links.account = {
            href: ''
        };

        // must return true, and pass in the new item if there were modifications
        deferred.resolve(true, halObj);
    }

```

In the following example we implement a counter tracking the total times we've called put() via the afterPut() event.
```js
    updateCnt: 0,
    afterPut: function(halObj, deferred) {
        this.afterPut += 1;
        deferred.resolve();
    }

```

Lastly, this example outlines how to perform a save through an injected service with an onPost() event.
```js
    onPost: function(halObj, deferred) {
        Service.post(halObj.serviceItem).then(function(response) {
            deferred.resolve();
        });
    }

```

#### Is there any way to know what links I have access to when working with Service.item?

Aside from calling all() you can get an array of the function names with Service.item.links.
