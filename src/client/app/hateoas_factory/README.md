# HATEOASFactory

HATEOASFactory outputs angular services based on a 'service definition' and combines it with their initial endpoint call to allow easy hal focused development within module controllers.

### Installation
Defined as a core MPS module and included via require. Example of  injection into a factory along with a service definition: 

```js
    define(['angular', 'contact'], 
    function(angular, contact) {
        'use strict';
        angular.module('mps.serviceRequestContacts')
        .factory('NewFactory', ['HATEOASFactory', 
            function(HATEOASFactory) {
                var serviceDefinition = {
                    serviceName: 'contacts'
                };
                
                return new HATEOASFactory(serviceDefinition);
            }
        ]);
    });
```

## Overview
When the app starts it makes an initial end point call to /mps/ for a 'list' of the services we provide access to. It looks something like the structure below:

```js
{
  "_links" : {
    "contacts" : {
      "href" : "https://api.venus-dev.lexmark.com/mps/contacts{?page,size,sort}",
      "templated" : true
    }
  }
}
```

As you can see in the structure above we have one endpoint defined in _links{} and it is called 'contacts'. This is the service name. This initial call is used to power all generated functions within HATEOASFactory. The above call is made by the HATEOASConfig module with behaves as the store for our service endpoints; however, the given endpoint is attached to all generated services. Once attached a service will have service.url'', and service.params{} properties.

Now that we know the end point is there we can create a service definition and actually get going.

## Service Definitions
Service Definitions are angular factories that house an object that combines with the injected HATEOASFactory to output a service. Below is a definition for the contact endpoint outlined above. Note how the serviceName matches the endpont key we were given. This is a required property.

```js
define(['angular', 'contact'], function(angular) {
    'use strict';
    angular.module('mps.serviceRequestContacts')
    .factory('Contacts', ['$translate', 'HATEOASFactory',
        var Contacts = {
            // service name must match to end point key
            serviceName: 'contacts',
            // given to grid for column sets
            columns: [
                {name: $translate.instant('CONTACT.EMAIL'), field: 'email'}
            ],
            // used to make client site routes consistent
            route: '/service_requests/contacts'
        };

        return new HATEOASFactory(Contacts);
        }
    ]);
});
```
Note any assigned defaults provided by HATEOASFactory will overwritten by provided service definitions properties as long as they have the same name. Further: functions, events, and objects can be outlined when needed.

## Using your new service within a controller
Now we have a service that will be generated by our factory. With this we can inject it elsewhere and begin to access our given endpoint.

### Getting paged content
Generally speaking our initital endpoint will return a collection of items. These items always end up in service.data[]. To make the initial call you do the following (again we used the assumed contacts service outlined above). With each page request the page{} property of the service is updated to match the response; along with params{}.


```js
    Contacts.get().then(function() {
        Contacts.data; // Has our collection
    });

```

To navigate within the context of the current page you can use next() and prev() which are based on the initial collections _links.self. They will return null if you cannot move in that direction.

```js
    Contacts.next().then(function(success) {
        Contacts.data; 
    });

    Contacts.prev().then(function(success) {
        Contacts.data; 
    });

```

To obtain a specific page use the following:

```js
    Contacts.params.page = 2;
    Contacts.params.size = 100;

    Contacts.get().then(function() {
        Contacts.data; // Page 2 size 100

        // You could reset to default param values with:
        Contacts.params = Contacts.defaultParams;
    });

```

### Getting single items
The services item{} property is set sometime after an initial paging call (as we do not know the end point to call). That said there is a provided pattern to call for a particular item only by ID. It is detailed at the bottom of this section; first we will outline the general cases.

Lets assume we have a set of items already in service.data[]. If we want to use the _links{} items of that particular item we need to set it in our services item{} property. If you were on a grid powered page reflecting a page collection you could do something like the following to obtain the item:

```js
    // in controller, function called in template
    $scope.goToContact = function(contact) {        
        Contacts.item = contact;

        // Call this to attach _links routes as functions
        // You wouldn't need this if you were creating a new item.
        Contacts.setupItem();
    }

    // if you know you need access to the items _links you can skip
    // the assignment and do:
    Contacts.setupItem(contact);

```

Now that we have something in Contacts.item a set of new functions related to the _links outline become available. For example; lets assume the items hal envelope had an 'account' link outling the items associated account; to get this you can do something like:

```js
    Contacts.item.account().then(function(processedResponse) {
        // then() gets back the full server response
        // We could set the item on another service with:
        Account.setItem(processedResponse);
    });

    // If we wanted to give params to Contacts.item.account()
    Contacts.item.account({key: 'value'}).then(function(processedResponse) {

    });

```

As mentioned above you can also directly call for an item; to do so use get():

```js
Contacts.get('123-XYT').then(function(processedResponse) {
    // this makes a call to contacts/123-XYT based on no HAL data
    // use at your own risk; since you are constructing the url from
    // something other than defined metadata.
});

```

NOTE: You could also make an http call manually and set the item on your service.

## Saving

There are two methods related to getting information to our end points.

#### Contacts.put() / Contacts.item.put()
put() will make a PUT request to our root path, updates mainly

#### Contacts.post() / Contacts.item.post()
put() will make a POST request to our root path, typically used for initial saves.

An example: 

```js
    // Saving the structure in service.item
    Contacts.item.put().then(function() {

    });

    // Saving a a new item, if no item is given service.item is sent if found
    Contacts.post(item).then(function() {

    });

```

## Working with Query Parameters
All services have a params{} property that defines the parameters and values for the needed calls. All parameters are sent with every call to Service.get() -- this is because the service defaults to using the entire set given to it by the intial endpoint call. Parameters set to null are never sent.

Example of a unmodified get() call:
```js
    // note sort is not sent because it defaults to null
    // .../contacts?page=0&size=20 
    Contacts.get().then(function() {

    });
```

Example of adding a custom parameters to the call:

```js
    // this is referred to as the options object
    // .../contacts?page=20&size=20&firstName=Gob&lastName=Blooth
    Contacts.get({
        params: {
            firstName: 'Gob',
            lastName: 'Blooth'
        }
    });

    // if you didn't want to send page/size you can set them to null
    // or do something like the below
    // .../contacts?firstName=Gob&lastName=Blooth
    Contacts.get({
        preventDefaultParams: true, // blocks native params
        params: {
            firstName: 'Gob',
            lastName: 'Blooth'
        }
    });

    // .../contacts?page=20&size=20&lastName=Blooth
    Contacts.params.lastName = 'Blooth';

    Contacts.get().then(function() {
        // if you had the need you could reset:
        Contacts.params = Contacts.defaultParams;
    });;

    // Options object can be given page/size as well
    // .../contacts?page=1&size=100
    Contacts.get({
        page: 1, // 0 index for pages so this is the second page
        size: 100
    }).then(function() {

    });

```

Lastly, working with parameters with link functions:

```js
    // .../devices/meter-reads?key=value
    Devices.item.meterReads({
        key: 'value',
    }).then(function() {

    });
```

## Working with collections (grids and etc)
The typical way to build out a grid with your service is to outline the following in a controller. The grid directive does need added to relevant templates and the grid module will need to be injected into the controller.

```js
    $scope.gridOptions = {};

    Contacts.get().then(function() {
        Grid.display(Contacts, $scope);
    }, function(reason) {
        NREUM.noticeError('Grid Load Failed for ' + Contacts.serviceName +  ' reason: ' + reason);
    });

```

#### Columns


## Events
There are a few events you can leverage within HATEOASFactory. They can be defined within the definition or attached to the service within the controller.


```js
    // fires before get executes, must return true or get() will fail
    beforeGet(halObj, deferred) 
    // fires when get begins
    onGet(halObj, deferred)
    // fires after get is successful 
    afterGet(halObj, deferred) 

    // fires before put executes, must return true or put() will fail
    beforePut(halObj, deferred) 
    onPut(halObj, deferred) 
    afterPut(halObj, deferred) 

    // fires before put executes, must return true or post() will fail
    beforePost(halObj, deferred) 
    onPost(halObj, deferred) 
    afterPost(halObj, deferred) 

    onNext(halObj, deferred) 

    onPrev(halObj, deferred) 

    // When an item is setup
    onItemSetup(halObj, deferred) 
```

## Examples and Solutions

#### If I were working with devices and wanted a particular devices meter read data -- how would I do it?

```js
    // Assuming Devices.item is defined
    Devices.item.meterReads().then(function(serverResponse) {

    });

```

#### What if I have a structure that relates to another service and was simply embedded in my current data -- put another way: How would I work with an address attached to a contact?

```js
    // You would use that service
    Addresses.item = Contacts.item.address;

    // Need a hal envelope for this items links? If so do:
    Addresses.item.self().then(function() {
        // Addresses.item should have been refreshed with a direct call
    });
```

#### How do I call an items self link?

```js
    Contacts.item.self().then(function() {

    });
```

#### How can I move two pages ahead?

```js
    Contacts.params.page = Contacts.params.page + 2;

    Contacts.get().then(function() {

    });

    // Or

    Contacts.get({
        page: Contacts.params.page + 2
    }).then(function() {

    });
```

#### How can I get the base url of the service?

```js
    Contacts.url; // String

```

#### How can I get the base url of an attached item?

```js
    Contacts.item._links.self.href;

```

#### I am creating an item across different views/templates -- how do I keep track of it?

Keep track of the item in Service.item as you work. When it is time to save call Service.post().


NOTE: To prevent refactoring getPage(), save(), and update() are still supported functions that call get(), post(), and put() respectively.


















